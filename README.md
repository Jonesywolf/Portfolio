# Portfolio Overview
This portfolio showcases a few of the projects made during my high school programming classes.
All of these applications were developed using Java8, JavaFX and JFoenix in Eclipse.

## Project Descriptions

### Tic Tac Toe
For the Tic Tac Toe application, a UI complete with sound effects, animation and custom UI elements were created. While I learned a lot creating the UI, I was also introduced to the minimax algorithm ([source](https://www.geeksforgeeks.org/minimax-algorithm-in-game-theory-set-3-tic-tac-toe-ai-finding-optimal-move/?ref=lbp)) for the first time while creating the computer opponent. I then created a difficulty system by applying a random modifier (called simplicity, since increasing the randomness would decrease the AI's difficulty, a poor programming choice in retrospect) to the score for each possible move generated by the algorithm.

```Java
/**
 * Determines the AI's next move
 * @param board  the Square[][] box in char[][] form
 * @param isAIPlayerX  determines whether the AI is playing as X or O
 * @return  int[] storing the row and column of the AI's best move
 */
public int[] findBestMove(char board[][], boolean isAIPlayerX) {
  // Stores the best possible score for the AI
  int bestScore;

  if (isAIPlayerX == true) {
    // Set it to a large negative value
    bestScore = -1000;
  }
  else {
    // Set it to a large positive value
    bestScore = 1000;
  }

  // Stores the best move at {row, col}
  int[] bestMove = {-1, -1};

  // Traverse all cells, evaluate minimax function
  // for all empty cells. And return the cell
  // with the optimal value (maximum for X, minimum for O).
  for (int y = 0; y < 3; y++) {
    for (int x = 0; x < 3; x++) {
      // Check if cell is empty
      if (board[y][x] == Square.BLANK) {

        // Stores the score for moving to this cell
        int moveScore;
        if (isAIPlayerX == true) {
          // Make the move
          board[y][x] = Square.X;
          moveScore = minimax(board, 0, false);
        }
        else {
          // Make the move
          board[y][x] = Square.O;
          moveScore = minimax(board, 0, true);
        }

        // Undo the move
        board[y][x] = Square.BLANK;

        // Generate a random int from 0 to simplicity
        Random rand = new Random();
          int randomNum = rand.nextInt(simplicity + 1);

        // X tries to maximize its score, so the best score is the highest one
        if (moveScore > bestScore && isAIPlayerX == true) {
          // If the absolute difference between the simplicity and the randomNum is less than 10,
          // or the best move has not yet been set (avoids unset moves), update the bestMove and bestScore
          if (Math.abs(simplicity - randomNum) < 10 || bestMove[0] == -1) {
            // Store the move's coordinates with the highest score
            bestMove[0] = y;
            bestMove[1] = x;
            bestScore = moveScore;
          }
        }
        // O tries to minimize its score, so the best score is the lowest one
        else if (moveScore < bestScore && isAIPlayerX == false) {
          // If the absolute difference between the simplicity and the randomNum is less than 10,
          // or the best move has not yet been set (avoids unset moves), update the bestMove and bestScore
          if (Math.abs(simplicity - randomNum) < 10 || bestMove[0] == -1) {
            // Store the move's coordinates with the lowest score
            bestMove[0] = y;
            bestMove[1] = x;
            bestScore = moveScore;
          }
        }
      }
    }
  }
  return bestMove;
}
```

### High Low Game
This is a game of chance where the user bets points on whether the dice will be above or below the most common roll for a given number of six-sided dice. For example, the most common roll for 2 dice is 7 so the user can bet whether the roll will be above or below 7, if they guess right, their betted points are doubled, if they guess wrong or the roll is a 7, they lose the betted points.

Getting 3D dice to work in JavaFX was quite tedious and required a thrid party library to get the mesh setup. To simulate the rolling animation, the camera's coordinates for the  ending face of the die roll along with some random points along the way yeild a biut of an unconvincing animation, but I learned a lot implementing it:

``` Java
/**
 * Adds keyFrames to the dice roll animation Timeline to rotate the
 * camera to an arbitrary point (if rollEndingFace is false) or to
 * the roll's ending face (if rollEndingFace is true)
 * @param fullDiceRoll  the Timeline containing the dice animation
 * @param animationDuration  the current duration of the animation
 * @param rotationDuration  the duration of the next rotation
 * @param rollEndingFace  determines whether to move the camera to an
 *                        arbitrary point or to the dice roll's ending face
 * @return Timeline the dice roll animation with the new keyFrames
 */
private Timeline rollDieOnce(Timeline fullDiceRoll, int animationDuration, int rotationDuration, boolean rollEndingFace) {
  // Set the next axis rotation coordinates to the current
  // rotations coordinates initially
  int nextAxisRotationX = currentRotations[0];
  int nextAxisRotationY = currentRotations[1];
  int nextAxisRotationZ = currentRotations[2];

  // If it's time to roll the last face
  if (rollEndingFace == true) {
    // Generate a random number between 1 and 6,
    // that's the current dice roll
    currentRoll = (int)(Math.random() * numDieSides) + 1;

    // Retrieve the rotation vectors to get to that face
    // and store them as the next axis rotations
    int[] faceCoords = allFaceCoords[currentRoll - 1];
    nextAxisRotationX = faceCoords[0];
    nextAxisRotationY = faceCoords[1];
    nextAxisRotationZ = faceCoords[2];
  }
  else {
    // Otherwise, the next axis rotations will be an arbitrary
    // rotation vector from -360 to 360 degrees
    nextAxisRotationX = (int)(Math.random() * 720) - 360;
    nextAxisRotationY = (int)(Math.random() * 720) - 360;
    nextAxisRotationZ = (int)(Math.random() * 720) - 360;
  }

  // Create the next keyFrames for each axis of rotation
  // Add rotationDuration to animationDuration for each keyFrame
  // The keyFrame for each rotation axis should be the nextAxisRotation
  KeyFrame nextStateX = new KeyFrame(
              Duration.millis(animationDuration + rotationDuration), 
              new KeyValue(xRotate.angleProperty(), nextAxisRotationX)
      );
  KeyFrame nextStateY = new KeyFrame(
              Duration.millis(animationDuration + rotationDuration), 
              new KeyValue(yRotate.angleProperty(), nextAxisRotationY)
      );
  KeyFrame nextStateZ = new KeyFrame(
              Duration.millis(animationDuration + rotationDuration), 
              new KeyValue(zRotate.angleProperty(), nextAxisRotationZ)
      );

  // Update currentRotations, to reflect the current position
  // of the camera
  currentRotations[0] = nextAxisRotationX;
  currentRotations[1] = nextAxisRotationY;
  currentRotations[2] = nextAxisRotationZ;

  // Add all the keyFrames form this rotation to the Timeline
  fullDiceRoll.getKeyFrames().addAll(nextStateX, nextStateY, nextStateZ); 

  // Return the updated Timeline
  return fullDiceRoll;
}
```

### Compound Investment Calculator
This is a basic compound investment calculator with regex-based input field validation. It calculates the interest using a a 2D array as specified by the assignment's requirements, see the code snippet below:
``` Java
// Create a 2D array to store calculation data
double[][] investment = new double[years][3];

// Store investment total
double investmentTotal = 0;
for (int year = 0; year < years; year++) {
  // Store the principal for each year
  investment[year][0] = yearlyPayment + investmentTotal;

  // Use the compound interest formula to determine the amount made each year
  investment[year][2] = investment[year][0] * Math.pow(1 + (interestRate/100)/compFreqPeriod, compFreqPeriod);

  // The interest is the difference between the two other values
  investment[year][1] = investment[year][2] - investment[year][0];

  // Update the investmentTotal
  investmentTotal = investment[year][2];
}
// Update label
lblInvestmentReturn.setText("Return on investment: $" + Console.roundDouble(investmentTotal, 2) + "");
```


